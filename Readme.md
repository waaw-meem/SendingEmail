<h1>Advance Authentication</h1>

<p>
Node JS has built-in package which is called "crypto" to generate some token which was random for every users.

Step 01: Import crypto package

<code>
const crypto = require('crypto')
</code>

Step 02: Add some other properties in database model

<p>
resetToken: This is a property or field of the object. It is of type String, which suggests that it will store a string value. In many cases, this might be used to store a token generated for resetting a user's password.

resetTokenExpiration: This is another property or field of the object. It is of type Date, which suggests that it will store a date and time value. This property is often used
</p>

<code>
  resetToken: String,
  resetTokenExpiration: Date,
</code>

Step 03: Now use crypto.randomBytes

<code>
 crypto.randomBytes(32, (err, buffer) => {
</code>

<p>
crypto.randomBytes(32, (err, buffer) => {: This line calls the randomBytes method from the crypto module. This method is used to generate a specified number of random bytes. In this case, it generates 32 random bytes. The method takes two arguments: the number of bytes to generate (32 in this case) and a callback function.

(err, buffer) => {: This is an arrow function used as the callback for the randomBytes method. It takes two parameters:

err: This parameter is used to capture any potential errors that may occur during the random byte generation process.
buffer: This parameter is used to store the generated random bytes.
</p>

Step 04: Use Buffer variable to generate random string and assign in token

<code>
const token = buffer.toString('hex');
<code>

<p>
const token = ...: This line declares a constant variable named token. The const keyword is used to create a variable that cannot be reassigned after it's initially defined.

buffer.toString('hex'): Here, it takes the buffer variable (which should contain the randomly generated bytes) and calls the toString method on it. The toString method is used to convert the content of the buffer into a string.

'hex': This argument passed to toString specifies the encoding format to use when converting the buffer to a string. In this case, 'hex' indicates that the bytes should be represented in hexadecimal format.
</p>

Step 05: Find Information about user such as email

<code>
    User.findOne({ email: req.body.email })
      .then(user => {
        if (!user) {
          req.flash('error', 'No account with that email found.');
          return res.redirect('/reset');
        }
        user.resetToken = token;
        user.resetTokenExpiration = Date.now() + 3600000;
        return user.save();
      })
      .then(result => {
        res.redirect('/');
        transporter.sendMail({
          to: req.body.email,
          from: 'wm401238@gmail.com',
          subject: 'Password reset',
          html: `
            <p>You requested a password reset</p>
            <p>Click this <a href="http://localhost:3000/reset/${token}">link</a> to set a new password.</p>
          `
        });
      })
</code>

<p>
User.findOne({ email: req.body.email }): This line is querying a database to find a user document based on the provided email address in the request body (req.body.email). It is using the findOne method of the User model or collection. This is a common operation in applications where you want to locate a user by their email address.

.then(user => { ... }): This code snippet is a promise chain, and it specifies what to do once the User.findOne operation is completed. It takes the user document (if found) as an argument for further processing.

if (!user) { ... }: Here, it checks if a user document was found. If no user is found with the provided email address, it sets a flash message indicating that no account with that email was found and redirects the user to the '/reset' route. This is a typical behavior for handling cases where the email provided does not match any existing user account.

user.resetToken = token;: If a user is found, it sets the resetToken property of the user document to the previously generated token. This token is typically used for identifying the user during the password reset process.

user.resetTokenExpiration = Date.now() + 3600000;: It sets the resetTokenExpiration property of the user document to a future timestamp. In this case, it's set to the current time (Date.now()) plus 3600000 milliseconds (1 hour). This sets an expiration time for the reset token, after which it will no longer be valid.

return user.save();: After updating the user document with the new resetToken and resetTokenExpiration values, it saves the changes to the database. This ensures that the updated user information is persisted.

.then(result => { ... }): Once the user document is successfully updated and saved in the database, this code block is executed. It's another promise in the chain.

res.redirect('/');: After saving the changes, it redirects the user to the root ('/') route, which could be a home or landing page.

transporter.sendMail({ ... }): This code sends an email to the user for the password reset process. It uses the transporter object (likely configured elsewhere in the code) to send an email to the email address provided in req.body.email. The email contains a link that the user can click to set a new password. It includes the token in the link to identify the user during the password reset process.
</p>
</p>

<h2>Understanding Validation</h2>

<p>
<h3>Basic Setup and Validation</h3>

For creating validating visit "express validator"

Step 01: Import express validator packages
<code>
npm install --save express-validator
</code>

Step 02: We use this package in controller and routes "Auth". In addition to that we use in 
post request where we send information or data

The below code is actually a import statement for this express validator package with sub package as well.
<code>
const expValidation = require('express-validator/check')

Other Code for extractiing other package

const {check} = require('express-validator/check')
</code>

Step 03: Add new middleware in routes signup the below code actually check the validator for email and the string parameter that I entered in the parameter is actually that parameter which we specified in form

<code>
router.post('/signup', check('email').isEmail() , authController.postSignup);
</code>

Below code actually works for different thing like to check errors is available or not.
<code>
 const errors = validationResult(req)
  if(!errors.isEmpty()){
    console.log(errors.array())
    return res.status(422).render('auth/signup',{
      path:'/signup',
      pageTitle:'Signup',
      errorMessage: errors.array()
    })
  }
</code>

To get validation message we use other thing in routes as well like to get our custom message

<code>
router.post('/signup', check('email').isEmail().withMessage('Please Enter a valid Email Address') , authController.postSignup);
</code>


<h3>Built-in custom validator</h3>

It is also we create in a very easiest way in routes. such as
<code>
.custom((value,{req}) => {
    if(value === 'test@test.com'){
        throw new Error('This Email address is forbidden')
    }
    return true
})
</code>

If the email is 'test@test.com', an error is thrown, and the validation chain stops.
If the email is not 'test@test.com', return true is executed, indicating that this custom validation rule has passed, and the validation chain continues to the next rule or middleware.


If we want to validate password then we use body instead of check method due to some several reasons. because we get password from req.body

<code>
body('password',"Please Enter a valid Password at least 5 characters")
.isLength({min:5,max:17})
.isAlphanumeric()
</code>

<h3>Async Validation</h3>

<p>
It means that when a user is already send a req for a signup then he do not signup again with the same email he or she get error msg so therefore we will do some changes in auth routes instead of controller auth
</p>

Route code
<code>
router.post(
    '/signup',
    [
      check('email')
        .isEmail()
        .withMessage('Please enter a valid email.')
        .custom((value, { req }) => {
          // if (value === 'test@test.com') {
          //   throw new Error('This email address if forbidden.');
          // }
          // return true;
          return User.findOne({ email: value }).then(userDoc => {
            if (userDoc) {
              return Promise.reject(
                'E-Mail exists already, please pick a different one.'
              );
            }
          });
        }),
      body(
        'password',
        'Please enter a password with only numbers and text and at least 5 characters.'
      )
        .isLength({ min: 5 })
        .isAlphanumeric(),
      body('confirmPassword').custom((value, { req }) => {
        if (value !== req.body.password) {
          throw new Error('Passwords have to match!');
        }
        return true;
      })
    ],
    authController.postSignup
  );
</code>

Controller code
<code>
exports.postSignup = (req, res, next) => {
  const email = req.body.email;
  const password = req.body.password;

  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    console.log(errors.array());
    return res.status(422).render('auth/signup', {
      path: '/signup',
      pageTitle: 'Signup',
      errorMessage: errors.array()[0].msg
    });
  }

  bcrypt
    .hash(password, 12)
    .then(hashedPassword => {
      const user = new User({
        email: email,
        password: hashedPassword,
        cart: { items: [] }
      });
      return user.save();
    })
    .then(result => {
      res.redirect('/login');
      // return transporter.sendMail({
      //   to: email,
      //   from: 'shop@node-complete.com',
      //   subject: 'Signup succeeded!',
      //   html: '<h1>You successfully signed up!</h1>'
      // });
    })
    .catch(err => {
      console.log(err);
    });
};
</code>


<h3>Uploading and Downloading files</h3>

<p>

</p>
Important Note: If you want to create a pdf then visit pdfkit website which is third party package will help you to create pdf in node server
</p>


<h2> Adding Pagination </h2>

<p></p>






